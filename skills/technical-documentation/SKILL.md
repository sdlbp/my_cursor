---
name: technical-documentation
description: 技术文档编写规范 - 生成 Vue 风格的由浅入深、通俗易懂的技术文档
---

# 技术文档编写规范

本规范用于生成高质量的技术文档，借鉴 Vue 文档风格，追求**由浅入深、通俗易懂、专业清晰**。

## 核心原则

### 1. 读者优先

- 假设读者是第一次接触这个模块
- 先回答"这是什么"和"为什么需要它"
- 用对比展示价值，而非罗列功能

### 2. 渐进式披露

- 先展示最简单的用法，再深入原理
- 每个概念都有独立的示例
- 复杂内容放在"深入理解"章节

### 3. 代码即文档

- 示例代码要能直接运行
- 注释说明关键步骤
- 避免过长的代码块（单块不超过 20 行）

---

## 文档结构模板

```markdown
# 模块名称

一句话说明模块用途和核心价值。

## 为什么需要它？

对比"没有它"和"有了它"的区别，用代码示例展示痛点和解决方案。

## 快速上手

最简单的完整示例，通常 2-3 步：
- 第一步：安装/引入
- 第二步：基本用法
- 第三步：查看结果

## 核心概念

用简洁的图示（ASCII 或 Mermaid）解释核心机制：
- 概念一：xxx
- 概念二：xxx

## API 速查

用表格形式列出所有 API，一目了然。

## 深入理解

解释内部实现原理，但要简化，突出关键逻辑。

## 实际应用示例

展示在真实项目中的用法。

## 要点回顾

用表格总结关键特性。
```

---

## 写作技巧

### 开篇

**推荐**：
```markdown
# RPC 通信模块

一个轻量的 Worker 通信工具，让主线程和 Worker 之间的调用像调用本地函数一样简单。
```

**避免**：
```markdown
# RPC 通信模块详解

本文档详细说明 OpenCode CLI 中 `util/rpc.ts` 模块的作用、实现原理和使用场景。该模块支持两种通信模式...
```

### 解释"为什么"

**推荐**：先展示痛点，再给出解决方案
```markdown
## 为什么需要它？

Web Worker 的原生通信方式是 `postMessage`，但直接使用有几个痛点：

// 原生方式：手动管理消息、缺乏类型提示
worker.postMessage({ type: 'fetch', data: { url: '...' } })

RPC 模块将这些复杂性封装起来：

// RPC 方式：类型安全、像调用普通函数
const result = await client.call("fetch", { url: '...' })
```

**避免**：直接罗列功能
```markdown
## 模块概述

该模块支持两种通信模式：
- RPC 调用：请求-响应模式
- 事件通知：发布-订阅模式
```

### 流程图示

**推荐**：简洁的 ASCII 图
```
主线程                    Worker
  |                         |
  |--- call("fetch") ------>|
  |                         | (执行)
  |<----- 返回结果 ---------|
```

**避免**：过于复杂的 Mermaid 图（超过 30 行）

### API 文档

**推荐**：表格形式速查
```markdown
| API | 说明 |
|-----|------|
| `Rpc.listen(rpc)` | 注册可被调用的方法 |
| `Rpc.emit(event, data)` | 向主线程推送事件 |
```

**避免**：冗长的函数签名说明
```markdown
### Rpc.listen()

**函数签名**:
export function listen(rpc: Definition)

**工作原理**:
- 注册全局 `onmessage` 处理器
- 解析接收到的 JSON 消息
...
```

### 代码示例

**推荐**：简洁、可运行、有注释
```typescript
// worker.ts
const rpc = {
  async greet(name: string) {
    return `Hello, ${name}!`
  }
}
Rpc.listen(rpc)
```

**避免**：过长、包含无关细节
```typescript
// worker.ts
import { Rpc } from "@/util/rpc"
import { GlobalBus } from "@/bus/global"
import { Log } from "@/util/log"
// ... 20 行 import

await Log.init({ print: process.argv.includes("--print-logs"), ... })
// ... 50 行配置代码
```

---

## 语言风格

### 推荐

- 使用主动语态："模块将复杂性封装起来"
- 使用"你"来称呼读者："你可以这样使用"
- 简短句子，一个概念一句话
- 用"就这么简单！"等友好语气

### 避免

- 被动语态过多："消息被发送到主线程"
- 过于正式："本模块旨在提供..."
- 长句子嵌套多个概念
- 堆砌专业术语而不解释

---

## 检查清单

生成文档后，用以下清单自检：

- [ ] 开篇一句话能说清模块用途吗？
- [ ] 有"为什么需要它"的对比说明吗？
- [ ] 快速上手示例能在 2 分钟内理解吗？
- [ ] 核心概念有图示辅助吗？
- [ ] API 有速查表吗？
- [ ] 代码示例简洁且可运行吗？
- [ ] 文档长度控制在 300 行以内吗？
- [ ] 有要点回顾总结吗？

---

## 示例对比

### 好的文档特征

| 特征 | 说明 |
|------|------|
| **开门见山** | 第一句话说明用途 |
| **问题导向** | 先讲为什么，再讲怎么做 |
| **渐进披露** | 由浅入深，逐步展开 |
| **视觉友好** | 表格、图示、代码块搭配 |
| **简洁有力** | 一个概念一个段落 |

### 差的文档特征

| 特征 | 问题 |
|------|------|
| **面面俱到** | 信息过载，重点不突出 |
| **上来就讲原理** | 读者还不知道为什么要学 |
| **代码过长** | 示例超过 30 行难以消化 |
| **术语堆砌** | 专业词汇不解释 |
| **缺少图示** | 纯文字描述复杂流程 |
